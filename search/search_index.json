{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wave Incrementally adopted framework for declarative development in Lua","title":"Home"},{"location":"#wave","text":"Incrementally adopted framework for declarative development in Lua","title":"Wave"},{"location":"api/","text":"Wave Methods createApp App createApp(config : { string: any }, root : Object) Creates an app of the specified object type with the given properties assigned, and children parented to it. Example local app = Wave . createApp ({ -- empty config }, Wave . createFragment ()) createObject Object createObject(objectType : Class | string, properties : { Symbol, any }, children : any) Creates an object of the specified object type with the given properties assigned, and children parented to it. Example local objectNode = Wave . createObject ( \"TextBox\" , { TextColor = Color3 . fromHex ( \"ffffff\" ), PlaceholderText = \"Type here...\" , [ Wave . Change . Text ] = textInput , }) createFragment Object createFragment(children : any) Creates a fragment object which can be used to create a hierarchy for children Example local objectNode = Wave . createFragment ({})","title":"Wave"},{"location":"api/#wave","text":"","title":"Wave"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#createapp","text":"App createApp(config : { string: any }, root : Object) Creates an app of the specified object type with the given properties assigned, and children parented to it. Example local app = Wave . createApp ({ -- empty config }, Wave . createFragment ())","title":"createApp"},{"location":"api/#createobject","text":"Object createObject(objectType : Class | string, properties : { Symbol, any }, children : any) Creates an object of the specified object type with the given properties assigned, and children parented to it. Example local objectNode = Wave . createObject ( \"TextBox\" , { TextColor = Color3 . fromHex ( \"ffffff\" ), PlaceholderText = \"Type here...\" , [ Wave . Change . Text ] = textInput , })","title":"createObject"},{"location":"api/#createfragment","text":"Object createFragment(children : any) Creates a fragment object which can be used to create a hierarchy for children Example local objectNode = Wave . createFragment ({})","title":"createFragment"},{"location":"api/app/","text":"App Caution This article is incomplete","title":"App"},{"location":"api/app/#app","text":"Caution This article is incomplete","title":"App"},{"location":"api/example/","text":"API API Type Description Paramters: Name Type Description N T D","title":"API"},{"location":"api/example/#api","text":"API Type Description Paramters: Name Type Description N T D","title":"API"},{"location":"api/object/","text":"Object Caution This article is incomplete","title":"Object"},{"location":"api/object/#object","text":"Caution This article is incomplete","title":"Object"},{"location":"api/state/","text":"State A state stores a value which can be changed and bound to properties or events. Static new State State.new(initialValue : any) Creates a new state initialized with the specified value computeFrom State State.computeFrom(...states : ...State, compute : (values : ...any) -> any) Creates a new state which is computed from a set of existing states. Whenever one of the existing states is updated the compute function is called with all the values of each state. Example local firstName = Wave . State . new ( \"John\" ) local lastName = Wave . State . new ( \"Smith\" ) local fullName = Wave . State . computeFrom ( firstName , lastName , function ( first , last ) return first .. \" \" .. last end ) Members Get any State:Get() Returns the value current stored by the state Set void State:Set(value : any) Sets the value stored by the state Track () -> void State:Track(callback : (oldValue : any, newValue : any) -> void) Tracks changes to the value by calling the callback each time the value is updated. Returns a function which stops tracking changes for the callback when called. Untrack void State:Untrack(callback : (oldValue : any, newValue : any) -> void) Removes the callback from the tracking list Chain State State:Chain(compute : (value : any) -> any) Experimental This feature is experimental and may be removed in the future without warning Creates a new State which computes a value from the current state. Example local count = Wave . State . new ( 2 ) local double = count : Chain ( function ( value ) return value * 2 end )","title":"State"},{"location":"api/state/#state","text":"A state stores a value which can be changed and bound to properties or events.","title":"State"},{"location":"api/state/#static","text":"","title":"Static"},{"location":"api/state/#new","text":"State State.new(initialValue : any) Creates a new state initialized with the specified value","title":"new"},{"location":"api/state/#computefrom","text":"State State.computeFrom(...states : ...State, compute : (values : ...any) -> any) Creates a new state which is computed from a set of existing states. Whenever one of the existing states is updated the compute function is called with all the values of each state. Example local firstName = Wave . State . new ( \"John\" ) local lastName = Wave . State . new ( \"Smith\" ) local fullName = Wave . State . computeFrom ( firstName , lastName , function ( first , last ) return first .. \" \" .. last end )","title":"computeFrom"},{"location":"api/state/#members","text":"","title":"Members"},{"location":"api/state/#get","text":"any State:Get() Returns the value current stored by the state","title":"Get"},{"location":"api/state/#set","text":"void State:Set(value : any) Sets the value stored by the state","title":"Set"},{"location":"api/state/#track","text":"() -> void State:Track(callback : (oldValue : any, newValue : any) -> void) Tracks changes to the value by calling the callback each time the value is updated. Returns a function which stops tracking changes for the callback when called.","title":"Track"},{"location":"api/state/#untrack","text":"void State:Untrack(callback : (oldValue : any, newValue : any) -> void) Removes the callback from the tracking list","title":"Untrack"},{"location":"api/state/#chain","text":"State State:Chain(compute : (value : any) -> any) Experimental This feature is experimental and may be removed in the future without warning Creates a new State which computes a value from the current state. Example local count = Wave . State . new ( 2 ) local double = count : Chain ( function ( value ) return value * 2 end )","title":"Chain"},{"location":"api/symbols/","text":"Symbols Symbols are used by Wave to represent fields or types as constants Class Wave.Class[.symbolName] A class symbol represents a type of object that can be created on the platform you are using. Hint Wave will automatically create a class symbol when you pass a string as the first argument to createObject so you never actually need to create one yourself. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , }) Property Wave.Property[.symbolName] A property symbol represents an assignable property of the object. Hint Wave will automatically create a property symbol when you use a string in the properties table of createObject so you never actually need to create one yourself. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , }) Event Wave.Event[.symbolName] An event symbol represents an event which can be listened to on the object. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , }) Change Wave.Change[.symbolName] A change symbol represents a property which invokes an event when it's value changes. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , }) Layer Wave.Layer[.symbolName] States Wave.States[.symbolName] Represents a state defined in the apps States table","title":"Symbols"},{"location":"api/symbols/#symbols","text":"Symbols are used by Wave to represent fields or types as constants","title":"Symbols"},{"location":"api/symbols/#class","text":"Wave.Class[.symbolName] A class symbol represents a type of object that can be created on the platform you are using. Hint Wave will automatically create a class symbol when you pass a string as the first argument to createObject so you never actually need to create one yourself. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , })","title":"Class"},{"location":"api/symbols/#property","text":"Wave.Property[.symbolName] A property symbol represents an assignable property of the object. Hint Wave will automatically create a property symbol when you use a string in the properties table of createObject so you never actually need to create one yourself. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , })","title":"Property"},{"location":"api/symbols/#event","text":"Wave.Event[.symbolName] An event symbol represents an event which can be listened to on the object. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , })","title":"Event"},{"location":"api/symbols/#change","text":"Wave.Change[.symbolName] A change symbol represents a property which invokes an event when it's value changes. Example Wave . createObject ( Wave . Class . TextBox , { [ Wave . Property . TextColor ] = Color3 . fromHex ( \"ffffff\" ), [ Wave . Event . MouseClick ] = event , [ Wave . Change . Text ] = textInput , })","title":"Change"},{"location":"api/symbols/#layer","text":"Wave.Layer[.symbolName]","title":"Layer"},{"location":"api/symbols/#states","text":"Wave.States[.symbolName] Represents a state defined in the apps States table","title":"States"},{"location":"guide/","text":"Getting Started Attention This guide is targetted at Roblox developers but most of the information you find here will still be applicable to other platforms. Introduction Wave is designed to be gradually adoptable so you can use it as little or as much as you want in your projects. This is one of the main advantages you get from using Wave over an alternative framework. Similar to many web frameworks Wave offers a declarative approach. This allows you to describe what your app should look like without needing to consider how you're going to pass data around to each component. If you want to learn more about the differences between Wave and other frameworks you can check out Comparison with Other Frameworks . Installation Right now, Wave is targetted at Roblox developers. You can download and insert an .rbxm into your place directly, use the Tide plugin or add it as a git dependency. via Tide Tide is a work in progress and not yet available, please use an alternative method for now. via rbxm Once the build process is setup, you'll be able to grab a copy of Wave via rbxm through the releases section on GitHub via git Wave can be found on GitHub Creating an App Let's start by creating a simple app. First we must initialize our app using the createApp method. This allows us to configure different settings for our app as well as create it. Wave . createApp ( config , rootObject ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"TextLabel\" , { Text = \"Hello world!\" , TextColor3 = Color3 . fromHex ( \"ffffff\" ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }) })) Great, we've just created our very first app using Wave! While our simple app is easy to get excited about it doesn't actually do much. We need some way to change the state of our app after it has been created. Managing State States allow us to store data which can be retrieved or updated later on. They are one of the fundamental parts of any Wave app. Creating a state is easy: local count = Wave . State . new ( 0 ) Once you have a state, it can be used directly in the place of a property. Take our example earlier, we can change the Text property of our TextLabel to be the newly created state: Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"TextLabel\" , { Text = count , TextColor3 = Color3 . fromHex ( \"ffffff\" ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }) })) We can then update the state whenever we want and our app will automatically reflect this change. for i = 1 , 10 do task . wait ( 1 ) -- wait one second count : Set ( count : Get () + 1 ) end With this, we now have a counter that will count up from zero to ten in ten seconds! But what if we only wanted the counter to increment when the user clicked a button? Handling Events We can do more than just set properties when creating an object. Sometimes it can be useful listen to events on an object, such as when a user clicks it. In this example we'll add a button with a counter on it that shows the number of times it has been clicked: local count = Wave . State . new ( 0 ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"Frame\" , { BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }, { Wave . createObject ( \"TextButton\" , { Text = count , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), BorderColor3 = Color3 . fromHex ( \"ffffff\" ), BorderSizePixel = 2 , Position = UDim2 . fromScale ( 0.5 , 0.5 ), AnchorPoint = Vector2 . new ( 0.5 , 0.5 ), [ Wave . Event . MouseButton1Click ] = function () count : Set ( count : Get () + 1 ) end }) }) })) States are clearly very useful then, but our button currently only shows the number of times it was clicked. It would be nice to add some additional text to go alongside that. Computing State Sometimes it can be useful to compose a value using another value, that is where computed states come in. In the previous example we saw how we could use a state to update a counter. We can create a new state from the count state which formats the value in a more user-friendly way. local count = Wave . State . new ( 0 ) local message = Wave . State . computeFrom ( count , function ( value ) return \"You have clicked \" .. value .. \" times\" end ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"Frame\" , { BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }, { Wave . createObject ( \"TextButton\" , { Text = message , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), BorderColor3 = Color3 . fromHex ( \"ffffff\" ), BorderSizePixel = 2 , Position = UDim2 . fromScale ( 0.5 , 0.5 ), AnchorPoint = Vector2 . new ( 0.5 , 0.5 ), [ Wave . Event . MouseButton1Click ] = function () count : Set ( count : Get () + 1 ) end }) }) })) Now everytime count is updated, our new state message will also update with the new value. Ready for some more? Next up we'll learn how to make reusable Components for our app","title":"Introduction"},{"location":"guide/#getting-started","text":"Attention This guide is targetted at Roblox developers but most of the information you find here will still be applicable to other platforms.","title":"Getting Started"},{"location":"guide/#introduction","text":"Wave is designed to be gradually adoptable so you can use it as little or as much as you want in your projects. This is one of the main advantages you get from using Wave over an alternative framework. Similar to many web frameworks Wave offers a declarative approach. This allows you to describe what your app should look like without needing to consider how you're going to pass data around to each component. If you want to learn more about the differences between Wave and other frameworks you can check out Comparison with Other Frameworks .","title":"Introduction"},{"location":"guide/#installation","text":"Right now, Wave is targetted at Roblox developers. You can download and insert an .rbxm into your place directly, use the Tide plugin or add it as a git dependency. via Tide Tide is a work in progress and not yet available, please use an alternative method for now. via rbxm Once the build process is setup, you'll be able to grab a copy of Wave via rbxm through the releases section on GitHub via git Wave can be found on GitHub","title":"Installation"},{"location":"guide/#creating-an-app","text":"Let's start by creating a simple app. First we must initialize our app using the createApp method. This allows us to configure different settings for our app as well as create it. Wave . createApp ( config , rootObject ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"TextLabel\" , { Text = \"Hello world!\" , TextColor3 = Color3 . fromHex ( \"ffffff\" ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }) })) Great, we've just created our very first app using Wave! While our simple app is easy to get excited about it doesn't actually do much. We need some way to change the state of our app after it has been created.","title":"Creating an App"},{"location":"guide/#managing-state","text":"States allow us to store data which can be retrieved or updated later on. They are one of the fundamental parts of any Wave app. Creating a state is easy: local count = Wave . State . new ( 0 ) Once you have a state, it can be used directly in the place of a property. Take our example earlier, we can change the Text property of our TextLabel to be the newly created state: Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"TextLabel\" , { Text = count , TextColor3 = Color3 . fromHex ( \"ffffff\" ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }) })) We can then update the state whenever we want and our app will automatically reflect this change. for i = 1 , 10 do task . wait ( 1 ) -- wait one second count : Set ( count : Get () + 1 ) end With this, we now have a counter that will count up from zero to ten in ten seconds! But what if we only wanted the counter to increment when the user clicked a button?","title":"Managing State"},{"location":"guide/#handling-events","text":"We can do more than just set properties when creating an object. Sometimes it can be useful listen to events on an object, such as when a user clicks it. In this example we'll add a button with a counter on it that shows the number of times it has been clicked: local count = Wave . State . new ( 0 ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"Frame\" , { BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }, { Wave . createObject ( \"TextButton\" , { Text = count , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), BorderColor3 = Color3 . fromHex ( \"ffffff\" ), BorderSizePixel = 2 , Position = UDim2 . fromScale ( 0.5 , 0.5 ), AnchorPoint = Vector2 . new ( 0.5 , 0.5 ), [ Wave . Event . MouseButton1Click ] = function () count : Set ( count : Get () + 1 ) end }) }) })) States are clearly very useful then, but our button currently only shows the number of times it was clicked. It would be nice to add some additional text to go alongside that.","title":"Handling Events"},{"location":"guide/#computing-state","text":"Sometimes it can be useful to compose a value using another value, that is where computed states come in. In the previous example we saw how we could use a state to update a counter. We can create a new state from the count state which formats the value in a more user-friendly way. local count = Wave . State . new ( 0 ) local message = Wave . State . computeFrom ( count , function ( value ) return \"You have clicked \" .. value .. \" times\" end ) Wave . createApp ({}, Wave . createObject ( \"ScreenGui\" , { IgnoreGuiInset = true , Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui }, { Wave . createObject ( \"Frame\" , { BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), Size = UDim2 . fromScale ( 1 , 1 ), }, { Wave . createObject ( \"TextButton\" , { Text = message , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = Color3 . fromHex ( \"eff8fa\" ), BorderColor3 = Color3 . fromHex ( \"ffffff\" ), BorderSizePixel = 2 , Position = UDim2 . fromScale ( 0.5 , 0.5 ), AnchorPoint = Vector2 . new ( 0.5 , 0.5 ), [ Wave . Event . MouseButton1Click ] = function () count : Set ( count : Get () + 1 ) end }) }) })) Now everytime count is updated, our new state message will also update with the new value. Ready for some more? Next up we'll learn how to make reusable Components for our app","title":"Computing State"},{"location":"guide/components/","text":"Components Attention This page is a work in progress. Expect more detailed information in the future. When designing apps, there are often elements you may build that you want to reuse elsewhere. In Wave, these are known as Components . A simple example of this could be a button that you've styled in a certain way. Here's a button with an icon: local icon = ... local text = ... local buttonColor = ... local onClick = ... Wave . createObject ( \"TextButton\" , { TextTransparency = 1 , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = buttonColor , [ Wave . Event . MouseButton1Click ] = onClick }, { -- Icon Wave . createObject ( \"ImageLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . fromOffset ( 24 , 24 ), Position = UDim2 . new ( 0 , 8 , 0.5 , 0 ), AnchorPoint = Vector2 . new ( 0 , 0.5 ), Image = icon }), -- Text Wave . createObject ( \"TextLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . new ( 1 , - 48 , 1 , 0 ), Position = UDim2 . fromOffset ( 40 , 0 ), Text = text }) }) To turn this into a Component all we need to do is wrap it in a function. local function IconButton ( properties , children ) return Wave . createObject ( \"TextButton\" , { TextTransparency = 1 , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = properties . BackgroundColor3 , [ Wave . Event . MouseButton1Click ] = properties . Clicked }, { -- Icon Wave . createObject ( \"ImageLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . fromOffset ( 24 , 24 ), Position = UDim2 . new ( 0 , 8 , 0.5 , 0 ), AnchorPoint = Vector2 . new ( 0 , 0.5 ), Image = properties . Icon }), -- Text Wave . createObject ( \"TextLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . new ( 1 , - 48 , 1 , 0 ), Position = UDim2 . fromOffset ( 40 , 0 ), Text = properties . Text }) }) end Then creating this component in our app is almost identical to creating any other class. Wave . createObject ( IconButton , { Icon = ..., Text = ..., BackgroundColor3 = ..., Clicked = ... })","title":"Components"},{"location":"guide/components/#components","text":"Attention This page is a work in progress. Expect more detailed information in the future. When designing apps, there are often elements you may build that you want to reuse elsewhere. In Wave, these are known as Components . A simple example of this could be a button that you've styled in a certain way. Here's a button with an icon: local icon = ... local text = ... local buttonColor = ... local onClick = ... Wave . createObject ( \"TextButton\" , { TextTransparency = 1 , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = buttonColor , [ Wave . Event . MouseButton1Click ] = onClick }, { -- Icon Wave . createObject ( \"ImageLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . fromOffset ( 24 , 24 ), Position = UDim2 . new ( 0 , 8 , 0.5 , 0 ), AnchorPoint = Vector2 . new ( 0 , 0.5 ), Image = icon }), -- Text Wave . createObject ( \"TextLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . new ( 1 , - 48 , 1 , 0 ), Position = UDim2 . fromOffset ( 40 , 0 ), Text = text }) }) To turn this into a Component all we need to do is wrap it in a function. local function IconButton ( properties , children ) return Wave . createObject ( \"TextButton\" , { TextTransparency = 1 , Size = UDim2 . fromOffset ( 200 , 50 ), BackgroundColor3 = properties . BackgroundColor3 , [ Wave . Event . MouseButton1Click ] = properties . Clicked }, { -- Icon Wave . createObject ( \"ImageLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . fromOffset ( 24 , 24 ), Position = UDim2 . new ( 0 , 8 , 0.5 , 0 ), AnchorPoint = Vector2 . new ( 0 , 0.5 ), Image = properties . Icon }), -- Text Wave . createObject ( \"TextLabel\" , { BackgroundTransparency = 1 , Size = UDim2 . new ( 1 , - 48 , 1 , 0 ), Position = UDim2 . fromOffset ( 40 , 0 ), Text = properties . Text }) }) end Then creating this component in our app is almost identical to creating any other class. Wave . createObject ( IconButton , { Icon = ..., Text = ..., BackgroundColor3 = ..., Clicked = ... })","title":"Components"},{"location":"guide/layer/","text":"","title":"Layer"},{"location":"guide/states/","text":"States States in more detail Using states for children Computing a value from another state Computing a value from multiple states","title":"States"},{"location":"guide/states/#states","text":"States in more detail","title":"States"},{"location":"guide/states/#using-states-for-children","text":"","title":"Using states for children"},{"location":"guide/states/#computing-a-value-from-another-state","text":"","title":"Computing a value from another state"},{"location":"guide/states/#computing-a-value-from-multiple-states","text":"","title":"Computing a value from multiple states"}]}